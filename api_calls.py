import requests
import os
import base64
from io import BytesIO
import streamlit as st
import concurrent.futures
import replicate

def generate_prompt(image):
    import replicate
    return replicate.run(
        "salesforce/blip:2e1dddc8621f72155f24cf2e0adbde548458d3cab9f00c0139eea840d0ac4746",
        input={
            "task": "image_captioning",
            "image": image
        }
    )

def add_text_to_image(image, text_title, text_subtitle, text_feature1, text_feature2, text_feature3):
    api_key = os.environ['APITEMPLATE_API_KEY']
    template1_id = os.environ['APITEMPLATE_TEMPLATE1_ID']
    template2_id = os.environ['APITEMPLATE_TEMPLATE2_ID']
    
    buffered = BytesIO()
    image.save(buffered, format="PNG")
    img_bytes = buffered.getvalue()

    data = {
        "overrides":[
            {
                "name":"text-title",
                "text":text_title,
            },
            {
                "name":"text-subtitle",
                "text":text_subtitle,
            },
            {
                "name":"text-list-1",
                "text":text_feature1,
            },
            {
                "name":"text-list-2",
                "text":text_feature2,
            },
            {
                "name":"text-list-3",
                "text":text_feature3,
            },
            {
                "name":"product-image",
                "src": f"data:image/png;base64,{base64.b64encode(img_bytes).decode()}"
            }
        ]
    }
    def create_image(template_id):
        response = requests.post(
            f"https://rest.apitemplate.io/v2/create-image?template_id={template_id}",
            headers={"X-API-KEY": api_key},
            json=data
        )
        return response
    
    with concurrent.futures.ThreadPoolExecutor() as executor:
        future_to_template = {
            executor.submit(create_image, template1_id): 'Template 1',
            executor.submit(create_image, template2_id): 'Template 2'
        }
        for future in concurrent.futures.as_completed(future_to_template):
            template_name = future_to_template[future]
            try:
                response = future.result()
                if response.status_code == 200:
                    download_url = response.json().get('download_url')
                    st.image(download_url, width=400)
                else:
                    st.write(f"Error in generating image with {template_name}")
            except Exception as e:
                st.write(f"Exception in processing {template_name}: {e}")

# Model1:  
# Image generated by this model is not that good.
def generate_logerzhu_adinpaint_images(prompt, file):
    input = {
        "prompt": prompt,
        "image_num": 2,
        "image_path": file,
        "product_size": "0.5 * width",
        "negative_prompt": "frames (worst quality:2)"
    }
    output = replicate.run(
        "logerzhu/ad-inpaint:b1c17d148455c1fda435ababe9ab1e03bc0d917cc3cf4251916f22c45c83c7df",
        input=input
    )
    print(output)
    generated_images = output[1:]
    for image in generated_images:
        st.image(image, width=400)
    
def generate_wolverinn_realistic_background(prompt, file):
    output = replicate.run(
        "wolverinn/realistic-background:ce02013b285241316db1554f28b583ef5aaaf4ac4f118dc08c460e634b2e3e6b",
        input={
            "seed": -1,
            "image": file,
            "steps": 20,
            "prompt": prompt,
            "cfg_scale": 7,
            "max_width": 1024,
            "max_height": 1024,
            "sampler_name": "DPM++ SDE Karras",
            "negative_prompt": "(deformed iris, deformed pupils, semi-realistic, cgi, 3d, render, sketch, cartoon, drawing, anime, mutated hands and fingers:1.4), (deformed, distorted, disfigured:1.3), poorly drawn, bad anatomy, wrong anatomy, extra limb, missing limb, floating limbs, disconnected limbs, mutation, mutated, ugly, disgusting, amputation, mug, cup",
            "denoising_strength": 0.75,
            "only_masked_padding_pixels": 4
        }
    )
    print(output)
    if not output:
        st.write("Loading...")
    else:
        image = output['image']
        st.image(image, width=400)